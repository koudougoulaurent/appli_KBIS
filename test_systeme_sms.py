#!/usr/bin/env python
"""
Test script pour le syst√®me de notifications SMS
Date: 20 juillet 2025
Version: 1.0

Ce script teste le syst√®me de notifications SMS pour les paiements en retard.
"""

import os
import sys
import django
from datetime import datetime, timedelta

# Configuration Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'gestion_immobiliere.settings')
django.setup()

from django.utils import timezone
from notifications.sms_service import SMSService, PaymentOverdueService
from notifications.models import Notification, NotificationPreference, SMSNotification
from contrats.models import Contrat
from paiements.models import Paiement
from proprietes.models import Propriete, Bailleur, TypeBien
from utilisateurs.models import Utilisateur
from proprietes.models import Locataire

def test_sms_service():
    """Test du service SMS"""
    print("üß™ TEST DU SERVICE SMS")
    print("=" * 50)
    
    # Test avec simulation
    sms_service = SMSService(provider='custom')
    
    # Test d'envoi de SMS
    result = sms_service.send_sms(
        phone_number="+33123456789",
        message="Test SMS - Votre loyer est en retard",
        notification_id=None
    )
    
    print(f"‚úÖ R√©sultat envoi SMS: {result}")
    
    # V√©rifier que l'enregistrement SMS a √©t√© cr√©√©
    sms_count = SMSNotification.objects.count()
    print(f"üìä Nombre d'enregistrements SMS: {sms_count}")
    
    return result.get('success', False)

def test_payment_overdue_detection():
    """Test de d√©tection des paiements en retard"""
    print("\nüîç TEST DE D√âTECTION DES PAIEMENTS EN RETARD")
    print("=" * 50)
    
    # Cr√©er des donn√©es de test
    test_data = create_test_data()
    
    # Service de d√©tection
    overdue_service = PaymentOverdueService()
    
    # V√©rifier les paiements en retard
    overdue_contracts = overdue_service._get_overdue_contracts(
        overdue_service._get_overdue_date()
    )
    
    print(f"üìã Contrats avec paiements en retard: {len(overdue_contracts)}")
    
    for contrat in overdue_contracts:
        print(f"  - Contrat {contrat.numero_contrat}: {contrat.propriete.titre}")
        print(f"    Locataire: {contrat.locataire.nom} {contrat.locataire.prenom}")
        print(f"    Loyer: {contrat.loyer_mensuel} F CFA")
    
    return len(overdue_contracts)

def test_notification_creation():
    """Test de cr√©ation des notifications"""
    print("\nüì¢ TEST DE CR√âATION DES NOTIFICATIONS")
    print("=" * 50)
    
    # Cr√©er une notification de test
    user = Utilisateur.objects.first()
    if not user:
        print("‚ùå Aucun utilisateur trouv√©")
        return False
    
    notification = Notification.create_notification(
        recipient=user,
        type='payment_overdue',
        title='Test - Paiement en retard',
        message='Ceci est un test de notification de paiement en retard.',
        priority='urgent'
    )
    
    print(f"‚úÖ Notification cr√©√©e: {notification}")
    print(f"üìä Type: {notification.get_type_display()}")
    print(f"üìä Priorit√©: {notification.get_priority_display()}")
    print(f"üìä Destinataire: {notification.recipient.username}")
    
    return True

def test_preferences_sms():
    """Test des pr√©f√©rences SMS"""
    print("\n‚öôÔ∏è TEST DES PR√âF√âRENCES SMS")
    print("=" * 50)
    
    user = Utilisateur.objects.first()
    if not user:
        print("‚ùå Aucun utilisateur trouv√©")
        return False
    
    # Cr√©er ou r√©cup√©rer les pr√©f√©rences
    preferences, created = NotificationPreference.objects.get_or_create(
        user=user,
        defaults={
            'sms_notifications': True,
            'payment_overdue_sms': True,
            'phone_number': '+33123456789'
        }
    )
    
    if created:
        print(f"‚úÖ Pr√©f√©rences cr√©√©es pour {user.username}")
    else:
        print(f"üìã Pr√©f√©rences existantes pour {user.username}")
    
    print(f"üì± SMS activ√©s: {preferences.sms_notifications}")
    print(f"üì± SMS retard de paiement: {preferences.payment_overdue_sms}")
    print(f"üì± Num√©ro de t√©l√©phone: {preferences.phone_number}")
    
    # Tester les pr√©f√©rences
    sms_prefs = preferences.get_sms_preferences()
    print(f"üìä Pr√©f√©rences SMS: {sms_prefs}")
    
    return preferences.sms_notifications

def test_complete_overdue_workflow():
    """Test du workflow complet de d√©tection et notification"""
    print("\nüîÑ TEST DU WORKFLOW COMPLET")
    print("=" * 50)
    
    # Cr√©er des donn√©es de test
    test_data = create_test_data()
    
    # Service complet
    overdue_service = PaymentOverdueService()
    
    # Ex√©cuter la v√©rification
    notifications_sent = overdue_service.check_overdue_payments()
    
    print(f"üì§ Notifications envoy√©es: {notifications_sent}")
    
    # V√©rifier les notifications cr√©√©es
    overdue_notifications = Notification.objects.filter(type='payment_overdue')
    print(f"üìä Notifications de retard cr√©√©es: {overdue_notifications.count()}")
    
    # V√©rifier les SMS envoy√©s
    sms_notifications = SMSNotification.objects.all()
    print(f"üì± SMS envoy√©s: {sms_notifications.count()}")
    
    for sms in sms_notifications:
        print(f"  - SMS √† {sms.phone_number}: {sms.status}")
    
    return notifications_sent > 0

def create_test_data():
    """Cr√©er des donn√©es de test"""
    print("\nüìù CR√âATION DES DONN√âES DE TEST")
    print("=" * 50)
    
    # Cr√©er un utilisateur de test
    user, created = Utilisateur.objects.get_or_create(
        username='test_locataire',
        defaults={
            'email': 'test@example.com',
            'first_name': 'Test',
            'last_name': 'Locataire'
        }
    )
    
    if created:
        print(f"‚úÖ Utilisateur cr√©√©: {user.username}")
    
    # Cr√©er un locataire
    locataire, created = Locataire.objects.get_or_create(
        nom='Test',
        prenom='Locataire',
        defaults={
            'email': 'test@example.com',
            'telephone': '+33123456789',
            'cree_par': user
        }
    )
    
    if created:
        print(f"‚úÖ Locataire cr√©√©: {locataire.nom} {locataire.prenom}")
    
    # Cr√©er un bailleur d'abord
    bailleur, created = Bailleur.objects.get_or_create(
        nom='Test',
        prenom='Bailleur',
        defaults={
            'email': 'bailleur@example.com',
            'telephone': '+33123456788',
            'adresse': '456 Rue Bailleur, Paris'
        }
    )
    
    # Cr√©er un type de bien
    type_bien, created = TypeBien.objects.get_or_create(
        nom='Appartement',
        defaults={'description': 'Appartement standard'}
    )
    
    # Cr√©er une propri√©t√©
    propriete, created = Propriete.objects.get_or_create(
        titre='Appartement Test',
        defaults={
            'adresse': '123 Rue Test',
            'ville': 'Paris',
            'code_postal': '75001',
            'pays': 'France',
            'type_bien': type_bien,
            'surface': 50.0,
            'nombre_pieces': 3,
            'nombre_chambres': 2,
            'nombre_salles_bain': 1,
            'loyer_actuel': 1200,
            'disponible': False,
            'bailleur': bailleur
        }
    )
    
    if created:
        print(f"‚úÖ Propri√©t√© cr√©√©e: {propriete.titre}")
    
    # Cr√©er un contrat
    contrat, created = Contrat.objects.get_or_create(
        propriete=propriete,
        locataire=locataire,
        defaults={
            'date_debut': timezone.now().date() - timedelta(days=30),
            'date_fin': timezone.now().date() + timedelta(days=335),
            'date_signature': timezone.now().date() - timedelta(days=30),
            'loyer_mensuel': 1200,
            'jour_paiement': 1,
            'est_actif': True
        }
    )
    
    if created:
        print(f"‚úÖ Contrat cr√©√©: {contrat.numero_contrat}")
    
    # Cr√©er des pr√©f√©rences SMS
    preferences, created = NotificationPreference.objects.get_or_create(
        user=user,
        defaults={
            'sms_notifications': True,
            'payment_overdue_sms': True,
            'phone_number': '+33123456789'
        }
    )
    
    if created:
        print(f"‚úÖ Pr√©f√©rences SMS cr√©√©es")
    
    return {
        'user': user,
        'locataire': locataire,
        'propriete': propriete,
        'contrat': contrat,
        'preferences': preferences
    }

def test_sms_statistics():
    """Test des statistiques SMS"""
    print("\nüìä TEST DES STATISTIQUES SMS")
    print("=" * 50)
    
    # Statistiques g√©n√©rales
    total_sms = SMSNotification.objects.count()
    sent_sms = SMSNotification.objects.filter(status='sent').count()
    delivered_sms = SMSNotification.objects.filter(status='delivered').count()
    failed_sms = SMSNotification.objects.filter(status='failed').count()
    pending_sms = SMSNotification.objects.filter(status='pending').count()
    
    print(f"üì± Total SMS: {total_sms}")
    print(f"üì§ SMS envoy√©s: {sent_sms}")
    print(f"‚úÖ SMS livr√©s: {delivered_sms}")
    print(f"‚ùå SMS √©chou√©s: {failed_sms}")
    print(f"‚è≥ SMS en attente: {pending_sms}")
    
    # Statistiques par fournisseur
    providers = SMSNotification.objects.values_list('provider', flat=True).distinct()
    for provider in providers:
        count = SMSNotification.objects.filter(provider=provider).count()
        print(f"üì° {provider}: {count} SMS")
    
    return total_sms

def main():
    """Fonction principale de test"""
    print("üöÄ D√âMARRAGE DES TESTS DU SYST√àME SMS")
    print("=" * 60)
    
    results = {}
    
    try:
        # Test 1: Service SMS
        results['sms_service'] = test_sms_service()
        
        # Test 2: D√©tection des paiements en retard
        results['overdue_detection'] = test_payment_overdue_detection()
        
        # Test 3: Cr√©ation des notifications
        results['notification_creation'] = test_notification_creation()
        
        # Test 4: Pr√©f√©rences SMS
        results['sms_preferences'] = test_preferences_sms()
        
        # Test 5: Workflow complet
        results['complete_workflow'] = test_complete_overdue_workflow()
        
        # Test 6: Statistiques
        results['statistics'] = test_sms_statistics()
        
    except Exception as e:
        print(f"‚ùå Erreur lors des tests: {e}")
        import traceback
        traceback.print_exc()
        return False
    
    # R√©sum√© des tests
    print("\n" + "=" * 60)
    print("üìã R√âSUM√â DES TESTS")
    print("=" * 60)
    
    for test_name, result in results.items():
        status = "‚úÖ R√âUSSI" if result else "‚ùå √âCHOU√â"
        print(f"{test_name.replace('_', ' ').title()}: {status}")
    
    success_count = sum(1 for result in results.values() if result)
    total_count = len(results)
    
    print(f"\nüìä R√©sultat global: {success_count}/{total_count} tests r√©ussis")
    
    if success_count == total_count:
        print("üéâ TOUS LES TESTS SONT R√âUSSIS !")
        return True
    else:
        print("‚ö†Ô∏è Certains tests ont √©chou√©")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1) 